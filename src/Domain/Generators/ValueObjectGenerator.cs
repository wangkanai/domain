// Copyright (c) 2014-2025 Sarin Na Wangkanai, All Rights Reserved.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Wangkanai.Domain.Generators;

/// <summary>
/// Source generator that creates optimized equality methods for ValueObjects.
/// Eliminates reflection overhead by generating direct property access at compile time.
/// </summary>
[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register for syntax notifications for classes that inherit from ValueObject
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsValueObjectCandidate(s),
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static m => m is not null);

        // Generate code for each ValueObject class
        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(spc, source!));
    }

    private static bool IsValueObjectCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { BaseList: not null } classDecl &&
               classDecl.BaseList.Types.Any(baseType => 
                   baseType.Type.ToString().Contains("ValueObject"));
    }

    private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
        if (classSymbol == null) return null;

        // Check if it inherits from ValueObject
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == "ValueObject")
            {
                var properties = classSymbol.GetMembers()
                    .OfType<IPropertySymbol>()
                    .Where(p => p.DeclaredAccessibility == Accessibility.Public && 
                               !p.IsStatic && 
                               p.GetMethod != null)
                    .Select(p => new PropertyInfo(p.Name, p.Type.ToDisplayString()))
                    .ToList();

                return new ClassInfo(
                    classSymbol.Name,
                    classSymbol.ContainingNamespace.ToDisplayString(),
                    properties);
            }
            baseType = baseType.BaseType;
        }

        return null;
    }

    private static void Execute(SourceProductionContext context, ClassInfo classInfo)
    {
        var sourceBuilder = new StringBuilder();
        
        sourceBuilder.AppendLine($@"// <auto-generated />
// Copyright (c) 2014-2025 Sarin Na Wangkanai, All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;

namespace {classInfo.Namespace};

partial class {classInfo.ClassName}
{{
    /// <summary>
    /// Generated optimized equality components method.
    /// This eliminates reflection overhead for {classInfo.Properties.Count} properties.
    /// </summary>
    protected override IEnumerable<object?> GetEqualityComponents()
    {{");

        // Generate direct property access for each property
        foreach (var property in classInfo.Properties.OrderBy(p => p.Name))
        {
            if (IsEnumerableType(property.TypeName))
            {
                sourceBuilder.AppendLine($@"
        // Handle enumerable property: {property.Name}
        if ({property.Name} is null)
        {{
            yield return null;
        }}
        else
        {{
            yield return '[';
            foreach (var item in {property.Name})
                yield return item;
            yield return ']';
        }}");
            }
            else
            {
                sourceBuilder.AppendLine($@"        yield return {property.Name};");
            }
        }

        sourceBuilder.AppendLine(@"    }

    /// <summary>
    /// Generated optimized GetHashCode method for maximum performance.
    /// </summary>
    public override int GetHashCode()
    {
        unchecked
        {
            var hash = 17;");

        foreach (var property in classInfo.Properties.OrderBy(p => p.Name))
        {
            sourceBuilder.AppendLine($@"            hash = hash * 23 + ({property.Name}?.GetHashCode() ?? 0);");
        }

        sourceBuilder.AppendLine(@"            return hash;
        }
    }

    /// <summary>
    /// Generated optimized Equals method with direct property comparison.
    /// </summary>
    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(this, obj)) return true;
        if (obj is null || GetType() != obj.GetType()) return false;
        
        var other = ({classInfo.ClassName})obj;");

        foreach (var property in classInfo.Properties.OrderBy(p => p.Name))
        {
            if (IsEnumerableType(property.TypeName))
            {
                sourceBuilder.AppendLine($@"        
        if (!EqualityComparer<{property.TypeName}>.Default.Equals({property.Name}, other.{property.Name}))
            return false;");
            }
            else
            {
                sourceBuilder.AppendLine($@"        
        if (!EqualityComparer<{property.TypeName}>.Default.Equals({property.Name}, other.{property.Name}))
            return false;");
            }
        }

        sourceBuilder.AppendLine(@"        
        return true;
    }
}");

        context.AddSource($"{classInfo.ClassName}.ValueObject.g.cs", 
            SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private static bool IsEnumerableType(string typeName)
    {
        return typeName.Contains("IEnumerable") || 
               typeName.Contains("List") || 
               typeName.Contains("[]") ||
               typeName.StartsWith("System.Collections");
    }

    private record ClassInfo(string ClassName, string Namespace, List<PropertyInfo> Properties);
    private record PropertyInfo(string Name, string TypeName);
}